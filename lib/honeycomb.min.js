!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).Honeycomb={})}(this,function(t){"use strict";"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var e,n=(function(t,e){t.exports=function(){var t={},e="Array Object String Date RegExp Function Boolean Number Null Undefined".split(" ");function n(){return Object.prototype.toString.call(this).slice(8,-1)}for(var r=e.length;r--;)t["is"+e[r]]=function(t){return function(e){return n.call(e)===t}}(e[r]);return t}()}(e={exports:{}},e.exports),e.exports),r=n.isObject,i=n.isNumber,o=n.isArray,s=n.isString;function u(t,e){return e+t*(1&e)>>1}function c(t,e){return(t%e+e)%e}function a(t,e){if(!/^(N|S)?(E|W)?$/i.test(t))throw new Error(`Invalid compass direction: ${t}. Choose from E, SE, S, SW, W, NW, N or NE.`);if(e=e.toLowerCase(),t=t.toUpperCase(),"pointy"===e&&["N","S"].includes(t))throw new Error(`Direction ${t} is ambiguous for pointy hexes. Did you mean ${t}E or ${t}W?`);if("flat"===e&&["E","W"].includes(t))throw new Error(`Direction ${t} is ambiguous for flat hexes. Did you mean N${t} or S${t}?`);return{pointy:{E:0,SE:1,SW:2,W:3,NW:4,NE:5},flat:{SE:0,S:1,SW:2,NW:3,N:4,NE:5}}[e][t]}function l(t,e){return i(t)||i(e)?i(t)?i(e)||(e=t):t=e:t=e=0,{x:t,y:e}}function f(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function h(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{},r=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),r.forEach(function(e){f(t,e,n[e])})}return t}function d(t,e){if(null==t)return{};var n,r,i=function(t,e){if(null==t)return{};var n,r,i={},o=Object.keys(t);for(r=0;r<o.length;r++)n=o[r],e.indexOf(n)>=0||(i[n]=t[n]);return i}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(r=0;r<o.length;r++)n=o[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(i[n]=t[n])}return i}function x(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=[],r=!0,i=!1,o=void 0;try{for(var s,u=t[Symbol.iterator]();!(r=(s=u.next()).done)&&(n.push(s.value),!e||n.length!==e);r=!0);}catch(t){i=!0,o=t}finally{try{r||null==u.return||u.return()}finally{if(i)throw o}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}const y=[{q:1,r:0},{q:0,r:1},{q:-1,r:1},{q:-1,r:0},{q:0,r:-1},{q:1,r:-1}],p=[{q:2,r:-1},{q:1,r:1},{q:-1,r:2},{q:-2,r:1},{q:-1,r:-1},{q:1,r:-2}],g={x:1e-6,y:1e-6},b=Math.sqrt(3);function q(t){let e=t.Hex;return function(){return Object.assign(this,e(...arguments))}}function m(){return{x:this.x,y:this.y}}function P(){return{q:this.q,r:this.r,s:this.s}}function v(t){let e,n,r=t.q,i=t.r;return this.isPointy()?(e=r+u(this.offset,i),n=i):(e=r,n=i+u(this.offset,r)),{x:e,y:n}}function w(){return"pointy"===this.orientation.toLowerCase()}function H(){return"flat"===this.orientation.toLowerCase()}function O(){return 2*this.size}function C(){return b/2*this.oppositeCornerDistance()}function E(){return this.isPointy()?this.oppositeSideDistance():this.oppositeCornerDistance()}function S(){return this.isPointy()?this.oppositeCornerDistance():this.oppositeSideDistance()}function j(t){let e=t.Point;return function(){const t=this.width(),n=this.height(),r=this.origin,i=r.x,o=r.y;return this.isPointy()?[e(t-i,.25*n-o),e(t-i,.75*n-o),e(.5*t-i,n-o),e(0-i,.75*n-o),e(0-i,.25*n-o),e(.5*t-i,0-o)]:[e(t-i,.5*n-o),e(.75*t-i,n-o),e(.25*t-i,n-o),e(0-i,.5*n-o),e(.25*t-i,0-o),e(.75*t-i,0-o)]}}function M(t){let e=t.Point;return function(){const t=this.origin,n=t.x,r=t.y;return e(this.width()/2-n,this.height()/2-r)}}function N(t){let e=t.Point;return function(){const t=this.q,n=this.r,r=this.size;let i,o;return this.isPointy()?(i=r*b*(t+n/2),o=3*r/2*n):(i=3*r/2*t,o=r*b*(n+t/2)),e(i,o)}}function T(t){let e=t.Point,n=t.Hex;return function(t,r){const i=this.size;let o,s,u;var c=e(t,r).subtract(this.center());return o=c.x,r=c.y,this.isPointy()?(s=(o*b/3-r/3)/i,u=2*r/3/i):(s=2*o/3/i,u=(-o/3+b/3*r)/i),n({q:s,r:u,s:-s-u}).round()}}function D(t){let e=t.Hex,n=t.Point;return function(t){const r=n(t),i=r.x,o=r.y;return e(this.x+i,this.y+o,h({},this))}}function $(t){let e=t.Hex,n=t.Point;return function(t){const r=n(t),i=r.x,o=r.y;return e(this.x-i,this.y-o,h({},this))}}function G(t){let e=t.Point;return function(t){const n=e(t),r=n.x,i=n.y;return this.x===r&&this.y===i}}function V(t){return Math.max(Math.abs(this.q-t.q),Math.abs(this.r-t.r),Math.abs(this.s-t.s))}function W(t){let e=t.Hex;return function(){let t=this.q,n=this.r,r=this.s,i=Math.round(t),o=Math.round(n),s=Math.round(r);const u=Math.abs(t-i),c=Math.abs(n-o),a=Math.abs(r-s);return u>c&&u>a?i=-o-s:c>a?o=-i-s:s=-i-o,e(h({},this,{q:i,r:o,s:s}))}}function A(t){let e=t.Hex;return function(t,n){const r=this.q*(1-n)+t.q*n,i=this.r*(1-n)+t.r*n;return e(h({},this,{q:r,r:i,s:-r-i}))}}function I(){return this.add(g)}function _(){return`${this.x},${this.y}`}const z={thirdCoordinate:function(t,e){return-t-e}};function X(t){let e=t.Hex;return function(t,n){return e().fromPoint(t,n)}}function Y(t){let e=t.Grid,n=t.Hex;return function(t){let r=t.width,i=t.height,o=t.start,s=t.direction,u=void 0===s?1:s,c=t.onCreate,a=void 0===c?()=>{}:c;o=n(o);const l=x({1:["q","r","s"],3:["r","s","q"],5:["s","q","r"]}[u],3),f=l[0],h=l[1],d=l[2],y=new e;for(let t=0;t<r;t++)for(let e=0;e<i;e++){const r=n(o.cubeToCartesian({[f]:t+o[f],[h]:e+o[h],[d]:-t-e+o[d]}));a(r,y),y.push(r)}return y}}function B(t){let e=t.Grid,n=t.Hex;return function(t){let r=t.size,i=t.start,o=t.direction,s=void 0===o?1:o,u=t.onCreate,c=void 0===u?()=>{}:u;i=n(i);const a={1:{rStart:()=>0,rEnd:t=>r-t},5:{rStart:t=>r-t,rEnd:()=>r+1}}[s],l=a.rStart,f=a.rEnd,h=new e;for(let t=0;t<r;t++)for(let e=l(t);e<f(t);e++){const r=n(i.cubeToCartesian({q:t+i.q,r:e+i.r,s:-t-e+i.s}));c(r,h),h.push(r)}return h}}function L(t){let e=t.Grid,n=t.Hex;return function(t){let r=t.radius,i=t.center,o=t.onCreate,s=void 0===o?()=>{}:o;i=n(i);const u=new e;for(let t=-r;t<=r;t++){const e=Math.max(-r,-t-r),o=Math.min(r,-t+r);for(let r=e;r<=o;r++){const e=n(i.cubeToCartesian({q:t+i.q,r:r+i.r,s:-t-r+i.s}));s(e,u),u.push(e)}}return u}}function k(t){let e=t.Grid,n=t.Hex,r=t.compassToNumberDirection,i=t.signedModulo;return function(t){let o=t.width,c=t.height,a=t.start,l=t.direction,f=void 0===l?n().isPointy()?0:1:l,h=t.onCreate,d=void 0===h?()=>{}:h;a=n(a),s(f)&&(f=r(f,a.orientation)),(f<0||f>5)&&(f=i(f,6));const y=x([["q","r","s"],["r","q","s"],["r","s","q"],["s","r","q"],["s","q","r"],["q","s","r"]][f],3),p=y[0],g=y[1],b=y[2],q=x(a.isPointy()?[o,c]:[c,o],2),m=q[0],P=q[1],v=new e;for(let t=0;t<P;t++){const e=u(a.offset,t);for(let r=-e;r<m-e;r++){const e=n(a.cubeToCartesian({[p]:r+a[p],[g]:t+a[g],[b]:-r-t+a[b]}));d(e,v),v.push(e)}}return v}}function F(t){return i(t)?this[t]:this[this.indexOf(t)]}function R(t){let e=t.isValidHex;return function(t,n){if(!e(n))return this;const r=i(t)?t:this.indexOf(t);return r<0?this.push(n):this[r]=n,this}}function U(t,e){const n=t.distance(e),r=1/Math.max(n,1);let i=[];for(let o=0;o<=n;o++){const n=t.nudge().lerp(e.nudge(),r*o).round();i.push(this.get(n))}return i}function J(t){let e=t.isValidHex;return function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(!e(t))throw new Error(`Invalid center hex: ${t}.`);if(!this.get(t))throw new Error(`Center hex with coordinates ${t} not present in grid.`);let i=[];for(let e=-n;e<=n;e++)for(let o=Math.max(-n,-e-n);o<=Math.min(n,-e+n);o++){const n=this.get(t.cubeToCartesian({q:t.q+e,r:t.r+o}));t.equals(n)&&!r||i.push(n)}return i.filter(Boolean)}}function K(t){let e=t.isValidHex,n=t.signedModulo,r=t.compassToNumberDirection;return function(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"all",o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!e(t))throw new Error(`Invalid hex: ${t}.`);const u=o?p:y;return"all"===i&&(i=[0,1,2,3,4,5]),[].concat(i).map(e=>{s(e)&&(e=r(e,t.orientation)),(e<0||e>5)&&(e=n(e,6));const i=u[e],o=i.q,c=i.r;return this.get(t.cubeToCartesian({q:t.q+o,r:t.r+c}))}).filter(Boolean)}}function Q(t){let e=t.Point;return function(t,n){let r;var i=e(t,n);return r=i.x,n=i.y,e(this.x+r,this.y+n)}}function Z(t){let e=t.Point;return function(t,n){let r;var i=e(t,n);return r=i.x,n=i.y,e(this.x-r,this.y-n)}}function tt(t){let e=t.Point;return function(t,n){let r;var i=e(t,n);return r=i.x,n=i.y,e(this.x*r,this.y*n)}}function et(t){let e=t.Point;return function(t,n){let r;var i=e(t,n);return r=i.x,n=i.y,e(this.x/r,this.y/n)}}function nt(t){let e=t.ensureXY;const n={add:Q({Point:s}),subtract:Z({Point:s}),multiply:tt({Point:s}),divide:et({Point:s})};function s(t,s){let u;return u=i(t)?e(t,s):o(t)?e(...t):r(t)?e(t.x,t.y):e(0),Object.assign(Object.create(n),u)}return s}const rt=nt({ensureXY:l});class it extends Array{static isValidHex(t){return!0===(t||{}).__isHoneycombHex}fill(){throw new TypeError("Grid.prototype.fill is not implemented")}includes(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return!!(this.indexOf(t,e)+1)}indexOf(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=this.length;let r=Number(e);for(t=rt(t),r=Math.max(r>=0?r:n+r,0);r<n;r++)if(this[r].equals(t))return r;return-1}lastIndexOf(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.length-1;const n=this.length;let r=Number(e);for(t=rt(t),r=r>=0?Math.min(r,n-1):n+r;r>=0;r--)if(this[r].equals(t))return r;return-1}push(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return super.push(...e.filter(it.isValidHex))}splice(t,e){if(null==e)return super.splice(t);for(var n=arguments.length,r=new Array(n>2?n-2:0),i=2;i<n;i++)r[i-2]=arguments[i];return super.splice(t,e,...r.filter(it.isValidHex))}unshift(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return super.unshift(...e.filter(it.isValidHex))}}const ot=nt({ensureXY:l}),st=function(t){let e=t.ensureXY,n=t.Point;return function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const s=function(t){let e=t.Point;return function(t,n){let r,i,o;var s=e(t,n);return r=s.x,n=s.y,this.isPointy()?(i=r-u(this.offset,n),o=n):(i=r,o=n-u(this.offset,r)),{q:i,r:o,s:-i-o}}}({Point:n}),c={__isHoneycombHex:!0,orientation:"pointy",origin:0,size:1,offset:-1,get q(){return this.cartesianToCube(this).q},get r(){return this.cartesianToCube(this).r},get s(){return this.cartesianToCube(this).s},add:D({Hex:l,Point:n}),cartesian:m,cartesianToCube:s,center:M({Point:n}),coordinates:m,corners:j({Point:n}),cube:P,cubeToCartesian:v,distance:V,equals:G({Point:n}),fromPoint:T({Point:n,Hex:l}),height:S,isFlat:H,isPointy:w,lerp:A({Hex:l}),nudge:I,oppositeCornerDistance:O,oppositeSideDistance:C,round:W({Hex:l}),set:q({Hex:l}),subtract:$({Hex:l,Point:n}),toCartesian:v,toCube:s,toPoint:N({Point:n}),toString:_,width:E},a=Object.assign(c,t);function l(t,n){let s,u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(r(t)){let e=t.q,r=t.r,o=t.s,l=d(t,["q","r","s"]);if(i(e)||i(r)||i(o)){if(e+r+o!==0)throw new Error(`Cube coordinates must have a sum of 0. q: ${e}, r: ${r}, s: ${o}, sum: ${e+r+o}.`);var c=a.cubeToCartesian({q:e,r:r,s:o});s=c.x,n=c.y}else s=t.x,n=t.y;u=l}else if(o(t)){var l=x(t,2);s=l[0],n=l[1],u={}}else s=t;return Object.assign(Object.create(a),Object.assign(u,e(s,n)))}return a.origin=n(a.origin),Object.assign(l,z),l}}({ensureXY:l,Point:ot}),ut=function(t){let e=t.extendHex,n=t.Grid,r=t.Point;const i=n.isValidHex;return function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:e();function s(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),s=1;s<e;s++)r[s-1]=arguments[s];return o(t)?r=t:r.unshift(t),new n(...r.filter(i))}return Object.assign(s,{Hex:t,isValidHex:i,pointToHex:X({Point:r,Hex:t}),parallelogram:Y({Grid:n,Hex:t}),triangle:B({Grid:n,Hex:t}),hexagon:L({Grid:n,Hex:t}),rectangle:k({Grid:n,Hex:t,compassToNumberDirection:a,signedModulo:c})}),Object.assign(n.prototype,{get:F,hexesBetween:U,hexesInRange:J({isValidHex:i}),neighborsOf:K({isValidHex:i,signedModulo:c,compassToNumberDirection:a}),set:R({isValidHex:i})}),s}}({extendHex:st,Grid:it,Point:ot});t.extendHex=st,t.defineGrid=ut,t.Point=ot,Object.defineProperty(t,"__esModule",{value:!0})});
//# sourceMappingURL=honeycomb.min.js.map
